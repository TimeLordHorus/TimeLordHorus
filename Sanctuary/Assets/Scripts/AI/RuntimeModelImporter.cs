using System;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.XR.Interaction.Toolkit;

namespace Sanctuary.AI
{
    /// <summary>
    /// Handles runtime import of GLB/GLTF models generated by the AI backend.
    /// Uses glTFast for efficient loading and creates interactable VR objects.
    /// </summary>
    public class RuntimeModelImporter : MonoBehaviour
    {
        [Header("Import Settings")]
        [SerializeField] private Transform spawnParent;
        [SerializeField] private Vector3 spawnOffset = new Vector3(0, 1.5f, 2f);
        [SerializeField] private float defaultScale = 1f;

        [Header("Interaction Setup")]
        [SerializeField] private bool makeInteractable = true;
        [SerializeField] private PhysicMaterial physicsMaterial;

        [Header("Optimization")]
        [SerializeField] private bool generateColliders = true;
        [SerializeField] private bool optimizeMesh = true;
        [SerializeField] private int maxTextureSize = 2048;

        private static RuntimeModelImporter instance;
        public static RuntimeModelImporter Instance => instance;

        private void Awake()
        {
            if (instance == null)
            {
                instance = this;
            }
            else
            {
                Destroy(gameObject);
            }

            if (spawnParent == null)
            {
                spawnParent = transform;
            }
        }

        /// <summary>
        /// Import a GLB model from a URL and spawn it in VR space
        /// </summary>
        public async Task<GameObject> ImportAndSpawnModel(string modelUrl, Vector3? customPosition = null)
        {
            Debug.Log($"[ModelImporter] Starting import from: {modelUrl}");

            try
            {
                GameObject modelObject = await LoadGLBFromURL(modelUrl);

                if (modelObject == null)
                {
                    Debug.LogError("[ModelImporter] Failed to load model");
                    return null;
                }

                // Position the model
                Vector3 spawnPosition = customPosition ?? (Camera.main.transform.position + Camera.main.transform.forward * spawnOffset.magnitude);
                modelObject.transform.position = spawnPosition;
                modelObject.transform.localScale = Vector3.one * defaultScale;

                // Setup for VR interaction
                if (makeInteractable)
                {
                    SetupVRInteraction(modelObject);
                }

                // Optimize for VR performance
                if (optimizeMesh)
                {
                    OptimizeModel(modelObject);
                }

                Debug.Log($"[ModelImporter] Model successfully imported and spawned at {spawnPosition}");
                return modelObject;
            }
            catch (Exception e)
            {
                Debug.LogError($"[ModelImporter] Import failed: {e.Message}");
                return null;
            }
        }

        /// <summary>
        /// Load GLB file from URL using glTFast
        /// NOTE: Requires glTFast package to be installed
        /// </summary>
        private async Task<GameObject> LoadGLBFromURL(string url)
        {
            // This is a placeholder implementation
            // When glTFast is installed, use this code:

            /*
            var gltf = new GLTFast.GltfImport();
            bool success = await gltf.Load(url);

            if (success)
            {
                GameObject instantiatedModel = new GameObject("GeneratedModel");
                instantiatedModel.transform.SetParent(spawnParent);

                bool instantiated = await gltf.InstantiateMainSceneAsync(instantiatedModel.transform);

                if (instantiated)
                {
                    return instantiatedModel;
                }
            }
            */

            // Temporary fallback: Create a placeholder cube
            Debug.LogWarning("[ModelImporter] glTFast not available, creating placeholder");
            GameObject placeholder = GameObject.CreatePrimitive(PrimitiveType.Cube);
            placeholder.name = "PlaceholderModel";
            placeholder.transform.SetParent(spawnParent);

            await Task.Delay(1000); // Simulate loading time

            return placeholder;
        }

        /// <summary>
        /// Setup XR Interaction components for the imported model
        /// </summary>
        private void SetupVRInteraction(GameObject model)
        {
            // Add Rigidbody for physics
            Rigidbody rb = model.GetComponent<Rigidbody>();
            if (rb == null)
            {
                rb = model.AddComponent<Rigidbody>();
            }
            rb.mass = 1f;
            rb.drag = 1f;
            rb.angularDrag = 0.5f;
            rb.useGravity = false; // Floating in VR space

            // Generate colliders if needed
            if (generateColliders)
            {
                Collider col = model.GetComponent<Collider>();
                if (col == null)
                {
                    // Try to use mesh collider, fallback to box
                    MeshFilter meshFilter = model.GetComponentInChildren<MeshFilter>();
                    if (meshFilter != null && meshFilter.sharedMesh != null)
                    {
                        MeshCollider meshCol = model.AddComponent<MeshCollider>();
                        meshCol.sharedMesh = meshFilter.sharedMesh;
                        meshCol.convex = true;
                        meshCol.material = physicsMaterial;
                    }
                    else
                    {
                        BoxCollider boxCol = model.AddComponent<BoxCollider>();
                        boxCol.material = physicsMaterial;
                    }
                }
            }

            // Add XR Grab Interactable
            XRGrabInteractable grabInteractable = model.GetComponent<XRGrabInteractable>();
            if (grabInteractable == null)
            {
                grabInteractable = model.AddComponent<XRGrabInteractable>();
            }

            // Configure grab settings
            grabInteractable.throwOnDetach = true;
            grabInteractable.throwSmoothingDuration = 0.25f;
            grabInteractable.movementType = XRBaseInteractable.MovementType.VelocityTracking;

            // Add audio feedback (optional)
            AudioSource audioSource = model.AddComponent<AudioSource>();
            audioSource.playOnAwake = false;
            audioSource.spatialBlend = 1f; // Full 3D sound

            Debug.Log($"[ModelImporter] VR interaction setup complete for {model.name}");
        }

        /// <summary>
        /// Optimize the model for VR performance
        /// </summary>
        private void OptimizeModel(GameObject model)
        {
            // Compress textures
            Renderer[] renderers = model.GetComponentsInChildren<Renderer>();
            foreach (Renderer renderer in renderers)
            {
                foreach (Material mat in renderer.materials)
                {
                    CompressTextures(mat);
                }
            }

            // Simplify meshes if polycount is too high
            MeshFilter[] meshFilters = model.GetComponentsInChildren<MeshFilter>();
            int totalPolycount = 0;
            foreach (MeshFilter mf in meshFilters)
            {
                if (mf.sharedMesh != null)
                {
                    totalPolycount += mf.sharedMesh.triangles.Length / 3;
                }
            }

            Debug.Log($"[ModelImporter] Total polycount: {totalPolycount}");

            // Add LOD group for complex models
            if (totalPolycount > 10000)
            {
                SetupLODGroup(model);
            }
        }

        /// <summary>
        /// Compress textures to reduce memory usage
        /// </summary>
        private void CompressTextures(Material material)
        {
            string[] textureProperties = { "_MainTex", "_BumpMap", "_MetallicGlossMap", "_EmissionMap" };

            foreach (string propName in textureProperties)
            {
                if (material.HasProperty(propName))
                {
                    Texture texture = material.GetTexture(propName);
                    if (texture != null && texture is Texture2D tex2D)
                    {
                        // Only resize if larger than max
                        if (tex2D.width > maxTextureSize || tex2D.height > maxTextureSize)
                        {
                            Debug.Log($"[ModelImporter] Texture {texture.name} will be compressed at runtime");
                            // Note: Runtime texture compression requires additional implementation
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Setup LOD group for performance
        /// </summary>
        private void SetupLODGroup(GameObject model)
        {
            LODGroup lodGroup = model.GetComponent<LODGroup>();
            if (lodGroup == null)
            {
                lodGroup = model.AddComponent<LODGroup>();
            }

            Renderer[] renderers = model.GetComponentsInChildren<Renderer>();

            LOD[] lods = new LOD[3];
            lods[0] = new LOD(0.6f, renderers); // High detail
            lods[1] = new LOD(0.3f, renderers); // Medium detail
            lods[2] = new LOD(0.1f, renderers); // Low detail

            lodGroup.SetLODs(lods);
            lodGroup.RecalculateBounds();

            Debug.Log($"[ModelImporter] LOD group configured for {model.name}");
        }

        /// <summary>
        /// Delete a spawned model
        /// </summary>
        public void DeleteModel(GameObject model)
        {
            if (model != null)
            {
                Debug.Log($"[ModelImporter] Deleting model: {model.name}");
                Destroy(model);
            }
        }

        /// <summary>
        /// Save model reference to user's collection
        /// </summary>
        public void SaveModelToCollection(GameObject model, string generationId)
        {
            // TODO: Implement saving to Firebase or local storage
            PlayerPrefs.SetString($"model_{generationId}", model.name);
            PlayerPrefs.Save();
            Debug.Log($"[ModelImporter] Model saved to collection: {generationId}");
        }
    }
}
